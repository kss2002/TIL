## 경로 탐색(Module Resolution)

경로 탐색(Module Resolution)은 `import`나 `require`로 연결된 모듈이 실제 어떤 파일을 가리키는지 결정하는 과정이에요.

번들러는 이를 위해 내부에 리졸버(Resolver)를 두고, 설정된 규칙에 따라 파일 경로를 찾아요.

리졸버는 모듈을 만났을 때 다음 두 가지 방식으로 파일을 탐색해요.

1. 경로가 명시된 경우 → 파일 시스템에서 직접 조회
2. 경로가 명시되지 않은 경우 → 설치된 패키지(`node_modules`)에서 탐색

지금부터 번들러가 실제로 어떤 규칙으로 모듈을 탐색하는지 구체적으로 살펴볼게요.

## 파일시스템 경로

경로(절대/상대)를 기반으로 모듈을 `import`했다면, 파일 시스템을 이용해서 모듈을 탐색해요.

```참고
파일 시스템(File System)이란?

운영 체제가 파일과 디렉토리를 조직하고 관리하는 방식이에요. 운영 체제는 계층적으로 저장된 파일 구조에서 절대 경로 또는 상대 경로로 사용해 파일을 찾고 관리해요.
```

### 절대 경로

절대 경로로 선언된 모듈이라면 루트 디렉토리부터 모듈을 탐색해요.

```
├─ src
│  ├─ components
│  │  └─ Header.tsx
```

```tsx
import { Header } from 'src/components/Header.tsx';
```

### 상대 경로

상대 경로로 정의된 모듈이라면 현재 파일을 기준으로 모듈을 탐색해요. 아래 예시에서는 `Layout.tsx`이 위치한 디렉토리인 `components`에서 `Header.tsx`를 찾아요.

```
├─ src
│  ├─ components
│  │  ├─ Header.tsx
│  │  └─ Layout.tsx
```

```tsx
// Layout.tsx
import { Header } from './Header.tsx';
```

## 모듈 경로

파일 시스템 경로가 아니라면, 다음과 같은 순서로 설치된 패키지에서 모듈을 찾고 해석해요.

1. `import` 및 `require` 구문으로 선언된 모듈이 Node.js 빌트인 모듈이거나, 브라우저 환경에서 기본 제공되는 API인지 확인해요.
2. 기본으로 제공되는 모듈이 아니라면, 패키지가 설치된 위치에서 해당 모듈의 `package.json`을 찾아요.
3. 패키지의 `package.json`에는 진입점 역할을 하는 `"exports"` 또는 `"main"` 필드가 있어요. 리졸버는 이 진입점을 시작으로 리졸브해요.

## 모듈 맵

경로 탐색은 단순히 파일 경로를 찾는 것으로 끝나지 않아요. 번들러는 탐색 결과를 모듈 맵(Module Map)에 저장해서, 동일 모듈에 대한 중복 탐색을 줄이고, 순환 참조에도 안정적으로 대응할 수 있도록 해요.

## 리졸브 규칙

번들러 설정 파일의 `resolve` 필드에서 모듈을 찾고 해석하는 규칙을 추가로 정의할 수 있어요.

### 탐색할 경로 설정하기: modules

`modules`는 번들러가 모듈을 탐색할 기준이 되는 디렉토리를 정의해요.

예를 들어, `modules`를 다음과 같이 설정해 볼게요.

- `path.resolve(__dirname)`: 프로젝트 루트 디렉토리를 기준으로 모듈을 탐색
- `node_modules`: 외부 패키지를 탐색하는 기본 경로

```js
// webpack.config.js
module.exports = {
  //...
  resolve: {
    modules: [
      path.resolve(__dirname), // 프로젝트 루트 기준 탐색
      'node_modules', // 외부 패키지를 탐색하는 기본 경로
    ],
  },
};
```

이제 설정한 디렉토리를 기준으로, 절대 경로처럼 모듈을 가져올 수 있어요.

```tsx
import calculate from 'src/helpers/calculate';
import _ from 'lodash';
```

### 확장자를 찾는 우선순위 설정하기: extensions

`extensions` 옵션을 설정하면, import 및 require 구문에서 확장자가 생략된 경우에도 지정된 확장자 목록의 순서대로 파일을 찾아 리졸브할 수 있어요.

예를 들어, `extensions` 옵션을 다음과 같이 설정하고, 확장자가 생략된 Header 컴포넌트를 가져오는 import 구문을 실행하면 번들러가 어떻게 동작하는지 살펴볼게요.

```js
// webpack.config.js
module.exports = {
  resolve: {
    extensions: ['.tsx', '.ts'],
  },
};
```

```tsx
import { Header } from './components/Header';
```

확장자가 생략되어 있지만, `extensions` 옵션에 정의된 확장자 목록 순서대로 파일을 찾고 해석해, `./components/Header.tsx`를 번들 파일에 포함해요.

```
/components
├── Header.ts
├── Header.tsx  (일치하는 파일 찾음)
└── Button.tsx
```

### 경로의 별칭 만들기: alias

`alias`를 사용하면 특정 디렉토리에 별칭을 지정할 수 있어요. 이렇게 설정하면 길거나 복잡한 상대 경로 대신 간결한 경로로 가져올 수 있어 가독성을 높일 수 있어요.

다음과 같이 `src/components`, `src/utils`와 같은 절대 경로를 `@components`, `@utils`라는 별칭으로 설정할 수 있어요.

```js
// webpack.config.js
const path = require('path');

module.exports = {
  resolve: {
    alias: {
      '@components': path.resolve(__dirname, 'src/components'),
      '@utils': path.resolve(__dirname, 'src/utils'),
    },
  },
};
```

이제 별칭만 사용해서 모듈을 가져올 수 있어요.

```tsx
// src/components/Header.tsx를 가져오는 경우
import Header from '@components/Header';

// src/utils/getSum.ts를 가져오는 경우
import getSum from '@utils/getSum';
```

## 컴파일러와 번들러의 리졸브 규칙 맞추기

컴파일 환경과 빌드 환경에서는 각각 다른 방식으로 경로를 해석하기 때문에, 설정이 일치하지 않으면 문제가 발생할 수 있어요.

TypeScript를 사용한다면 번들러(웹팩, Vite...)와의 경로 해석하는 규칙을 맞추는 것이 중요해요.

### 환경설정

TypeScript 컴파일러가 모듈의 경로를 찾는 방식은 `tsconfig.json`에서 다음 옵션을 통해 설정할 수 있어요.

- `baseUrl`: 모듈을 찾을 때 기준이 되는 디렉토리를 설정해요.
- `paths`: 특정 디렉토리를 별칭(alias)로 매핑할 수 있어요.

```json
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": "./",
    "paths": {
      "@components/*": ["src/components/*"],
      "@utils/*": ["src/utils/*"]
    }
  }
}
```

그리고 번들러가 동일한 규칙을 따르도록 아래와 같이 설정해요.

```js
// webpack.config.js
const path = require('path');

module.exports = {
  resolve: {
    alias: {
      '@components': path.resolve(__dirname, 'src/components'),
      '@utils': path.resolve(__dirname, 'src/utils'),
    },
  },
};
```

### 리졸브 규칙 동기화

TypeScript의 `baseUrl` 및 `paths` 설정을 자동으로 동기화하려면, `tsconfig-paths` 플러그인을 사용할 수 있어요.

이 플러그인은 빌드 타임에 `tsconfig.json`에 정의된 경로 설정을 읽고, `alias`에 자동으로 반영해줘요.

```js
// webpack.config.js
const path = require('path');
const TsconfigPathsPlugin = require('tsconfig-paths-webpack-plugin');

module.exports = {
  resolve: {
    plugins: [new TsconfigPathsPlugin()],
  },
};
```

## 다음 단계

경로 탐색을 이해했다면, 이제 번들러가 다양한 파일 형식을 어떻게 처리하는지 알아볼 차례예요. 다음 문서에서는 로더(Loader)에 대해 배워볼게요.
