## 코드 스플리팅 (Code Splitting)

코드 스플리팅(Code Splitting)은 하나의 큰 번들을 여러 개의 작은 청크(chunk)로 나누는 기술이에요. 이를 통해 초기 로딩 속도를 개선하고, 필요한 코드만 필요한 시점에 로드할 수 있어요.

## 코드 스플리팅이 필요한 이유

모든 코드를 하나의 번들로 만들면 다음과 같은 문제가 발생해요:

- 초기 로딩 시간이 길어져요
- 사용자가 방문하지 않는 페이지의 코드까지 다운로드해요
- 코드 일부만 수정해도 전체 번들을 다시 다운로드해야 해요

코드 스플리팅을 사용하면 이러한 문제를 해결할 수 있어요.

## 코드 스플리팅 방법

웹팩에서는 세 가지 방식으로 코드 스플리팅을 할 수 있어요.

### 1. 진입점 분리 (Entry Points)

여러 개의 진입점을 설정하여 번들을 나눌 수 있어요.

```js
// webpack.config.js
module.exports = {
  entry: {
    main: './src/index.js',
    admin: './src/admin.js',
  },
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
};
```

이렇게 하면 `main.bundle.js`와 `admin.bundle.js` 두 개의 번들이 생성돼요.

하지만 이 방법은 두 진입점이 같은 모듈을 사용하면 중복 코드가 포함되는 문제가 있어요.

### 2. 중복 방지 (Prevent Duplication)

`SplitChunksPlugin`을 사용하면 공통 모듈을 별도의 청크로 분리할 수 있어요.

```js
// webpack.config.js
module.exports = {
  entry: {
    main: './src/index.js',
    admin: './src/admin.js',
  },
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  optimization: {
    splitChunks: {
      chunks: 'all',
    },
  },
};
```

이렇게 설정하면 공통으로 사용하는 모듈(예: React, Lodash)이 자동으로 별도 청크로 분리돼요.

### 3. 동적 임포트 (Dynamic Import)

가장 강력하고 유연한 방법은 동적 임포트를 사용하는 거예요. 런타임에 필요한 시점에 모듈을 로드할 수 있어요.

```js
// 기존 방식
import { add } from './math';
console.log(add(1, 2));

// 동적 임포트
button.addEventListener('click', async () => {
  const { add } = await import('./math');
  console.log(add(1, 2));
});
```

동적 임포트를 사용하면 웹팩이 자동으로 별도의 청크를 생성해요.

## React에서 코드 스플리팅

React에서는 `React.lazy()`와 `Suspense`를 사용하여 컴포넌트 수준에서 코드 스플리팅을 할 수 있어요.

```jsx
import React, { Suspense } from 'react';

// 동적 임포트로 컴포넌트를 lazy 로딩
const AdminPage = React.lazy(() => import('./pages/AdminPage'));
const UserPage = React.lazy(() => import('./pages/UserPage'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>로딩 중...</div>}>
        <AdminPage />
      </Suspense>
    </div>
  );
}
```

사용자가 실제로 해당 페이지를 방문할 때만 컴포넌트 코드가 로드돼요.

## 라우트 기반 코드 스플리팅

가장 일반적인 패턴은 라우트(페이지)별로 코드를 분리하는 거예요.

```jsx
import React, { Suspense } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));
const Contact = React.lazy(() => import('./pages/Contact'));

function App() {
  return (
    <Router>
      <Suspense fallback={<div>로딩 중...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/contact" element={<Contact />} />
        </Routes>
      </Suspense>
    </Router>
  );
}
```

## SplitChunks 주요 옵션

`splitChunks` 옵션을 세밀하게 조정할 수 있어요.

```js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all', // 'all', 'async', 'initial'
      minSize: 20000, // 청크 최소 크기 (바이트)
      maxSize: 244000, // 청크 최대 크기
      minChunks: 1, // 모듈이 최소한 몇 번 사용되어야 분리할지
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10,
        },
        common: {
          minChunks: 2,
          priority: 5,
          reuseExistingChunk: true,
        },
      },
    },
  },
};
```

### cacheGroups

특정 조건에 맞는 모듈들을 그룹화하여 별도의 청크로 분리할 수 있어요.

```js
cacheGroups: {
  // node_modules의 코드를 vendor 청크로 분리
  vendor: {
    test: /[\\/]node_modules[\\/]/,
    name: 'vendors',
    priority: 10,
  },
  // React 관련 라이브러리만 따로 분리
  react: {
    test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
    name: 'react-vendor',
    priority: 20,
  },
}
```

## 청크 이름 지정하기

동적 임포트에 주석을 추가하여 청크 이름을 지정할 수 있어요.

```js
// webpackChunkName 매직 코멘트 사용
const AdminPage = React.lazy(
  () => import(/* webpackChunkName: "admin" */ './pages/AdminPage'),
);
```

이렇게 하면 `admin.chunk.js` 같은 이름으로 청크가 생성돼요.

## 프리로드 & 프리페치

자주 사용되는 코드는 미리 로드하여 성능을 개선할 수 있어요.

```js
// Prefetch: 브라우저가 한가할 때 미리 로드
import(/* webpackPrefetch: true */ './utils/analytics');

// Preload: 현재 화면에 필요하니 우선적으로 로드
import(/* webpackPreload: true */ './components/Modal');
```

```참고
Preload vs Prefetch

**Preload**: 현재 페이지에서 곧 필요한 리소스를 우선적으로 로드해요. 높은 우선순위로 즉시 다운로드돼요.

**Prefetch**: 미래에 필요할 수 있는 리소스를 브라우저가 한가할 때 로드해요. 낮은 우선순위로 백그라운드에서 다운로드돼요.
```

## 다음 단계

코드 스플리팅으로 번들을 나눴다면, 이제 사용하지 않는 코드를 제거하는 트리셰이킹에 대해 알아볼게요.
