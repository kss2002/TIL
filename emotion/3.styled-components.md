# Emotion의 styled API

> styled-components 스타일의 컴포넌트 생성 방법

## @emotion/styled란?

`@emotion/styled`는 styled-components와 거의 동일한 API를 제공하는 패키지다. 스타일이 적용된 React 컴포넌트를 생성할 수 있다.

## 설치

```bash
npm install @emotion/styled @emotion/react
```

## 기본 사용법

### 1. 기본 스타일드 컴포넌트

```jsx
import styled from '@emotion/styled';

const Button = styled.button`
  background-color: #3498db;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;

  &:hover {
    background-color: #2980b9;
  }
`;

function App() {
  return <Button>Click me!</Button>;
}
```

### 2. Props 기반 동적 스타일링

```jsx
const Button = styled.button`
  background-color: ${(props) => (props.primary ? '#3498db' : '#95a5a6')};
  color: white;
  padding: ${(props) => (props.size === 'large' ? '15px 30px' : '10px 20px')};
  font-size: ${(props) => (props.size === 'large' ? '18px' : '14px')};
  border: none;
  border-radius: 4px;
  cursor: pointer;
`;

function App() {
  return (
    <>
      <Button primary>Primary Button</Button>
      <Button size="large">Large Button</Button>
      <Button primary size="large">
        Primary Large
      </Button>
    </>
  );
}
```

### 3. 객체 스타일 문법

```jsx
const Card = styled.div({
  backgroundColor: 'white',
  borderRadius: '8px',
  padding: '20px',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',
});

// props와 함께 사용
const FlexContainer = styled.div((props) => ({
  display: 'flex',
  justifyContent: props.center ? 'center' : 'flex-start',
  alignItems: 'center',
  gap: props.gap || '16px',
}));
```

## 스타일 확장 (Extending Styles)

기존 컴포넌트의 스타일을 확장할 수 있다:

```jsx
const Button = styled.button`
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
`;

const PrimaryButton = styled(Button)`
  background-color: #3498db;
  color: white;

  &:hover {
    background-color: #2980b9;
  }
`;

const DangerButton = styled(Button)`
  background-color: #e74c3c;
  color: white;

  &:hover {
    background-color: #c0392b;
  }
`;
```

## as prop으로 태그 변경

렌더링되는 HTML 태그를 동적으로 변경할 수 있다:

```jsx
const Button = styled.button`
  padding: 10px 20px;
  background: #3498db;
  color: white;
  text-decoration: none;
  display: inline-block;
`;

function App() {
  return (
    <>
      <Button>일반 버튼</Button>
      <Button as="a" href="/link">
        링크 버튼
      </Button>
      <Button as="div">Div 버튼</Button>
    </>
  );
}
```

## 커스텀 컴포넌트 스타일링

다른 React 컴포넌트를 스타일링할 수 있다:

```jsx
// 기존 컴포넌트
function CustomLink({ className, children, ...props }) {
  return (
    <a className={className} {...props}>
      {children}
    </a>
  );
}

// styled로 감싸기
const StyledLink = styled(CustomLink)`
  color: #3498db;
  text-decoration: none;

  &:hover {
    text-decoration: underline;
  }
`;
```

**주의**: 커스텀 컴포넌트를 스타일링하려면 반드시 `className` prop을 전달받아 적용해야 한다!

## TypeScript와 함께 사용

```tsx
interface ButtonProps {
  primary?: boolean;
  size?: 'small' | 'medium' | 'large';
}

const Button = styled.button<ButtonProps>`
  background-color: ${(props) => (props.primary ? '#3498db' : '#95a5a6')};
  padding: ${(props) => {
    switch (props.size) {
      case 'small':
        return '5px 10px';
      case 'large':
        return '15px 30px';
      default:
        return '10px 20px';
    }
  }};
  color: white;
  border: none;
  border-radius: 4px;
`;
```

## css prop과 styled 비교

- css prop의 재사용성은 낮음. styled는 높음.
- css prop의 가독성은 간단한 경우에 좋음. styled는 복잡한 경우에 좋음.
- css prop은 props 전달이 직접 처리되어야 함. styled는 자동 전달됨.
- css prop은 컴포넌트화가 불가능. styled는 가능.

## 언제 styled를 사용할까?

- 여러 곳에서 재사용되는 컴포넌트
- 복잡한 props 기반 스타일링
- 디자인 시스템 구축 시
- 코드 가독성이 중요할 때
