# Emotion 베스트 프랙티스

> 실무에서 Emotion을 효과적으로 사용하기 위한 팁들

## 1. 스타일 컴포넌트 분리

스타일드 컴포넌트를 별도 파일로 분리하면 관리가 편해진다:

```
components/
├── Button/
│   ├── index.jsx        # 로직
│   ├── Button.styles.js # 스타일
│   └── Button.test.js   # 테스트
```

```jsx
// Button.styles.js
import styled from '@emotion/styled';

export const StyledButton = styled.button`
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
`;

export const ButtonIcon = styled.span`
  margin-right: 8px;
`;

// index.jsx
import { StyledButton, ButtonIcon } from './Button.styles';

export function Button({ icon, children }) {
  return (
    <StyledButton>
      {icon && <ButtonIcon>{icon}</ButtonIcon>}
      {children}
    </StyledButton>
  );
}
```

## 2. 컴포넌트 네이밍 컨벤션

```jsx
// ✅ Good: styled 접두사 또는 Container/Wrapper 사용
const StyledHeader = styled.header`...`;
const CardWrapper = styled.div`...`;
const ButtonContainer = styled.div`...`;

// ❌ Bad: 역할이 불분명한 이름
const Div1 = styled.div`...`;
const MyStyles = styled.div`...`;
```

## 3. Props 기반 스타일 패턴

### Variant 패턴

```jsx
const variants = {
  primary: css`
    background: #3498db;
    color: white;
  `,
  secondary: css`
    background: #95a5a6;
    color: white;
  `,
  danger: css`
    background: #e74c3c;
    color: white;
  `,
};

const Button = styled.button`
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  ${props => variants[props.variant] || variants.primary}
`;

// 사용
<Button variant="primary">Primary</Button>
<Button variant="danger">Delete</Button>
```

### Size 패턴

```jsx
const sizes = {
  small: css`
    padding: 6px 12px;
    font-size: 12px;
  `,
  medium: css`
    padding: 10px 20px;
    font-size: 14px;
  `,
  large: css`
    padding: 14px 28px;
    font-size: 16px;
  `,
};

const Button = styled.button`
  border: none;
  border-radius: 4px;
  ${(props) => sizes[props.size] || sizes.medium}
`;
```

## 4. 조건부 스타일링

```jsx
// ✅ Good: css 함수를 사용한 조건부 스타일
const Button = styled.button`
  padding: 10px 20px;

  ${(props) =>
    props.disabled &&
    css`
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    `}

  ${(props) =>
    props.fullWidth &&
    css`
      width: 100%;
    `}
`;

// ❌ Bad: 삼항 연산자 남용
const BadButton = styled.button`
  padding: ${(props) => (props.large ? '14px' : props.small ? '6px' : '10px')};
  font-size: ${(props) =>
    props.large ? '16px' : props.small ? '12px' : '14px'};
`;
```

## 5. 성능 최적화

### 동적 스타일을 컴포넌트 외부에서 정의

```jsx
// ✅ Good: 컴포넌트 외부에 정의
const cardStyle = css`
  padding: 20px;
  border-radius: 8px;
`;

function Card() {
  return <div css={cardStyle}>Content</div>;
}

// ❌ Bad: 렌더링마다 새로운 스타일 객체 생성
function BadCard() {
  return (
    <div
      css={css`
        padding: 20px;
        border-radius: 8px;
      `}
    >
      Content
    </div>
  );
}
```

### shouldForwardProp 사용

커스텀 props가 DOM으로 전달되는 것을 방지:

```jsx
import styled from '@emotion/styled';

const Input = styled('input', {
  shouldForwardProp: (prop) => !['hasError', 'isValid'].includes(prop),
})`
  border: 2px solid
    ${(props) => (props.hasError ? 'red' : props.isValid ? 'green' : 'gray')};
  padding: 10px;
`;

// hasError, isValid props는 DOM으로 전달되지 않음
<Input hasError placeholder="Error state" />;
```

## 6. 반응형 디자인

### 미디어 쿼리 상수 정의

```jsx
// breakpoints.js
const breakpoints = {
  mobile: 480,
  tablet: 768,
  laptop: 1024,
  desktop: 1200,
};

export const mq = {
  mobile: `@media (max-width: ${breakpoints.mobile}px)`,
  tablet: `@media (max-width: ${breakpoints.tablet}px)`,
  laptop: `@media (max-width: ${breakpoints.laptop}px)`,
  desktop: `@media (min-width: ${breakpoints.desktop}px)`,
};

// 사용
import { mq } from './breakpoints';

const Container = styled.div`
  padding: 40px;

  ${mq.tablet} {
    padding: 20px;
  }

  ${mq.mobile} {
    padding: 10px;
  }
`;
```

### facepaint 라이브러리 활용

```jsx
import facepaint from 'facepaint';

const mq = facepaint([
  '@media(min-width: 420px)',
  '@media(min-width: 768px)',
  '@media(min-width: 1024px)',
]);

const Container = styled.div(
  mq({
    padding: ['10px', '20px', '30px', '40px'],
    fontSize: ['14px', '16px', '18px', '20px'],
  }),
);
```

## 7. Transient Props ($ 접두사)

styled-components v5.1+에서 도입된 패턴으로, DOM으로 전달되지 않는 props:

```jsx
// $ 접두사가 붙은 props는 DOM으로 전달되지 않음
const Button = styled.button`
  background: ${(props) => (props.$primary ? 'blue' : 'gray')};
  font-size: ${(props) => props.$fontSize || '14px'};
`;

<Button $primary $fontSize="16px">
  Click me
</Button>;
```

> ⚠️ 참고: 이 기능은 `@emotion/styled`에서는 기본 지원되지 않으며, `shouldForwardProp`을 사용해야 한다.

## 8. 테스트 용이성

테스트를 위해 data 속성 추가:

```jsx
const Button = styled.button`
  /* styles */
`;

function SubmitButton({ children }) {
  return <Button data-testid="submit-button">{children}</Button>;
}

// 테스트
const button = screen.getByTestId('submit-button');
```

## 요약

- **파일 분리** - `.styles.js` 파일로 스타일을 분리하면 관리가 편해진다
- **Variant/Size** - 객체 기반으로 스타일 변형을 관리하면 확장성이 좋다
- **shouldForwardProp** - DOM으로 전달되면 안 되는 커스텀 props를 필터링한다
- **미디어 쿼리 상수** - 상수로 정의하면 반응형 디자인의 일관성을 유지할 수 있다
- **컴포넌트 외부 정의** - 스타일을 컴포넌트 외부에 정의하면 불필요한 리렌더링을 방지한다
